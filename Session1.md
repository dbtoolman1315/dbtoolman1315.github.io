##数据平面编程
###三个平面
1.数据平面：
一般指的是说如何去转发这个数据的这些算法，就这个设备如何去把一个报文按照二层去，或者按三层去转发到别的端口。
2.控制平面：
它指的一般是一些像路由协议，像一些这个二三层协议，它是来计算说如何去做路由，算出来的路由它会下发给数据平面的。数据平面和控制平面它是有一个相互交互的关系。
3.管理平面：
管理控制平面，往往是和人比较接近部分。

###NOS （network operation system）
很长一部分时间数据平台部分是在不在这NOS里边，我们数据平面的这个功能都是通过一些固定功能的交换芯片来实现。那他基于这些不可编程固定功能的交换芯片做开发的时候，那问题就来了，也就是交换芯片功能是固定的，反过来，如果芯片可以编程，就可以通过p4编程的方式把用户或者自己的想法发到这个芯片上边来，做到可以控制的数据平面，也就是现在的数据平面就是整个 NOS 的一部分。这也是符合从上到下设计这么一个理念。**就是我需要什么样的网络，我需要什么样的功能，我通过P4编程的形式，我把它告诉这个芯片，它来实现这样的功能。**
###固定与可编程芯片
那他们都是流水线架构，他们都是把这个流水线分成一个一个的所谓 stage 一个阶段。在这个阶段里面的内容是主要区别的部分。可编程的交换片里边是一切都是可编程的，每个表都是自己定义的，而固定功能芯片的里边的这个表都是提前定义好的，我比如说我这个 Mac 表它有多大。它占用的一些资源，那是它们提前定义好了。而在可编程芯片上，是说我这些资源都是统一的，都是比如说一个小块。那它的功能也刚开始的时候也不固定，而是我在通过 p4编程编译以后，我把它下载下来，我这个p4程序需要你这些内存做二层转发。

###P4设计目标
p4这个数据平面的这个编程语言，我们简单地来说，就他要来做一些这个报文头的一个转换，或者说我们跟外部的一些组件的一个接口

###p4(可编程的协议无关的报文处理器)
Programming Protocol-Independent Packet Processors

##P4<sub>16 Data Plane Model
#### PISA - Protocol-Indep Switching Architecture & Match—Action Tables

![第一步](图片/1.png)
把这个模型抽象出来，那首先这个这边的这些箭头一般是指就是说这个报文，报文进来那它会进来，之后它会先经过这个Parser，Parser就是解析器，可编程的这个解析器。个解析器它来做的事情就是比如说这个编程者
会去声明一个头，就是说你这个报文定义的一些头，这个Parser就是来编程者告诉这个Parser怎么来认识这些头，分别都是什么，比如IP,TCP等。
![第二部](图片/2.png)
处理信息，可编程的 match action pipeline，
我们先把这个报文你关心的那些头把它解出来。写出来了你再找这个 pipeline 里面来去查找，那查找的话也就是你要去定义一些 table，就是编程怎么来定义一些 table，table 之间的这个逻辑，就是你要给这个报文的处理逻辑。然后你处理完了之后，你再这边会有个 Deparser,就是把这些头给它填到这里面，按照你指定的这个顺序把它填好，然后再把它串行缓输出去。

![第三个](图片/3.png)
![第四个](图片/4.png)
比如说我们这边加一个报文，来了这边就启动各种不同的颜色，是指给出来的这个不同的这个头嘛。比如说这个形态头就是 IP 头，或者说在这个 UDP 什么头。然后你就报文进来了，之后通过这个 Parser 就会把这几个我把它截出来，写出来了之后我们这个 table 它就会去查表，查完了之后它你可能也会得到一些中间的一些表，可以做修改等操作。最后一个是这个处理完了之后，你再通过这个 Deparser，然后把这个头再给它重新组装，然后按照你既定的这个顺序排列好.
大家可以看得到我们这个报文处理就是大家对从左边一直往右边走，这也是流水线一个架构,然后它其实每一个始终周期，它就可以处理一个报文。所以它进来每一个时钟周期过来的话，它保额都往前走一步，每个时钟周期都可以出一个包。

![图片忆](图片/1758a50496b1c906ae9fbab855c8249.png)
首先会有一个 key，也会有 action，然后还有 action data，也就说你要去查这个表的关键字是什么。然后控制平面，就你 people 出来定义这个格式，就是你这个 table，你这个表的这个查到的就关键字动作，然后以及你要携带的数据。你是定义好这个格式控制平面就来填充，然后这里面来填充他会有命中跟不命中，如果说不命中的话，他还会有个 default action 对，然后以及 default action 的这个 data 我们可以看。~~26:10~~比如说这边是一个你在他的解析出来这个报文的头，或者说这个 Meta data 是作为这个输入。所以你会从这里面来选择。嗯，你这个 table 要去查找的这个 key 关键字，比如说我们选了这几个，要橙色的，绿色的，蓝色的，这几个我们作为它的 key，然后它会来查查标。在查这个表，查了之后，他就会有这个结果吗？有 hit 或者说 miss诶，就会有从这边对应的来取它这个指令，那个这个 entry 诶这其他的这个指令跟这个要操作的这个数据。最终他会去更改，就是有可能会去更改你这个 head，或者所谓的 data，就是你去通过这个指令码去操作它。然后最后你把你这个查表之后，然后你会去修改，或者说对这个进行操作，然后他就会得到一个更新后的这个数据，然后再把它输出去.
######访问控制列表(ACL)是一种基于包过滤的访问控制技术，它可以根据设定的条件对接口上的数据包进行过滤，允许其通过或丢弃。访问控制列表被广泛地应用于路由器和三层交换机，借助于访问控制列表，可以有效地控制用户对网络的访问，从而最大程度地保障网络安全。 


#### The concept of a P4 Architecture
#####PISA is not a whole switch
![第五张](图片/5.png)
这个PISA，它是一个这个架构，但是对于一个整个这个交换机来说的话，它其实并不是一个完整的。因为真正的一个交换芯片的话，它不仅仅是处理单播，还要处理组播，还要管一些队列调度等等这些相关的。所以这个PISA这个架构，它并不是一个完整的这个交换机。
红色的这一部分。就是像那个报文的这个 IO
数据包复制引擎(PRE) Traffic Manager
一些固有的元数据，比如一个包没有转发进来的端口，但是这个元数据可以标示出这个信息。

##### PISA Pipelines can vary
![第六张](图片/6.jpg)
那实际上它这个 pipeline 也是可以多样的，就说它的组合形式，其实可以很多种。那PISA是一个最原始的一个架构，比如说我们也可以说在这个处理过程中，我可以放两个 parser,可以灵活扩展

###编程Program
![第七个](图片/7.png)
入口与出口 ingress and egress 3*2
固有的这元数据是在哪里，其实也可以看这两个文件，就是我们会去 include 这两个p4文件
这是一个是 parser，一个是 control，一个是 deparser，就把这6个块把它组装成pipeline。
#### Defining Header Types
![头结构](图片/8.jpg)
bit<1> int<1> 有符号无符号
比如eth的头，48位源地址，48位目的地址，16位type
**其他的属性**：
1.成员是有顺序的，也就说你这个 header 你到时候提交，在 deparser 提交的时候，它就是按这个顺序出去的。
2.header的定义的它必须要有自己的对齐。
3.header是否有效。
#### Organizing Headers and Global Metadata for Ingress
![上层的结构](图片/9.jpg)
进一步的封装，然后我们也可以把这三个头，把它再加到一个结构体里面，就是这样子定义成 my ingress head 就是这部分。
#### Defining the Ingress Parser
![定义入口解析器](图片/10.jpg)
他的这部分我们看右边这个图了，就是这里面我们可以看到有一些圆圈，就是一个 state，然后这个红色的这个箭头线就是说这个 state 到下一个 state 这个这种跳转这画的这些示意图了。然后我们可以看一下简单的来看一下怎么来写。因为Parser的话，它是解析这个进来的这个报文，所以会有个 packet in，它是表示是我从网络 Mac 接口那边传进来的这个比特流。然后你可以用你自己的定义的这些结构，或者说头来定义你自己需要去解析的这一部分，那这里面要注意一个是说这里面是都是有方向的，就是有 in 或者 out，对应图中的绿色和右边的红色蓝色。
**Parsing 开始于 "start" state**
ingress_intrinsic_metadata：比如说这个报文进来的这个时间戳的信息，他在这个结构里面也有。也就是这个并不属于这个原始报文里面的内容，而是芯片帮他加进去了。advance就是说我直接跳的这部分数据我不需要，我直接跳过它，跳掉它。那我先把固有的这个原数据解完了之后，指针偏移，没有取数据。下面我就是我要去看到的这个真实常见的这个网络报文了
**extract 就是提取 header**
**transition就是跳到下一个状态**
如红色的圈。
**select 跳转选项**
如eth_type 0x0800 就跳到 ipv4
accept就是结束了
### Ingress Control
![sd](图片/12.jpg)
也就是match-actions部分
它就会有一部分是这个用户的这部分，这也就是这个蓝色箭头的一部分。我们在 parser 这边解完了之后我们会传这个信息过来。
还有固有的部分，parser and deparser部分，输出到下一个部分的。 还有tm  这个报文是丢掉还是入那个队列。是组播还是其他操作。

ig_intr_md 上一级解析出来的metadata
ig_prsr_md 它自己也会产生一些源数据。他产生的原数据就会放到这个数据里面来。
ig_dprsr_md 输出到deparser的
ig_tm_md 这个报文是丢掉还是入那个队列。是组播还是其他操作。
![sds](图片/13.jpg)
control 这一部分，成交的这一部分会分成两个小部分，一部分是说做这个资源的声明。比如说你去定义一些变量，或者定义一个 table action，所出现的声明就是你要选 a，然后 table table t，然后还有一块是 apply 这一块。Apply 这一块就是把这些资源这个逻辑关系，也以及它的这个去让它去执行这个查找。
action send:这个报文发送到某端口它这里面,所以我们是在操作这个 tm 的这个 intr_md。

table 关键字是解出来的这个 IPV4 是头里面的这个东西，exact 表示精确查找
actions 要干什么，这里面填的是一个 action 的 list，一个列表。
还有一个就是你可以来定义说我这个表要多大，那你就可以 size 等于就是这里是写的是128K。这个一个 table 呢，就定义好了
lpm 最长匹配关键字去查
**以上在这里是刚才的这个资源的声明**

**处理逻辑**
在apply里边定义
![sd](图片/14.jpg)
是否命中，host这张表，没有就查lpm这个表

**注意**
in out，这个又是一个什么概念？挺好的，就说我要读了之后我又会去修改，然后又要传出去，in就是说我只要我自己用，我不用不会输出了。

### Deparser
![dsd](图片/15.jpg)
再给它重新组装，然后变成一个报文出去。
他只有说当这个 header 在 value 的比特是会置上的，他这个才会真正的从这里面出去的，因为有的时候我们比如说vlan，我们可能会把它删掉。

### Egress
![sd](图片/16.jpg)
空的。

### Assembing 
![sd](图片/17.jpg)
要处理最后我们就把它我们写好了，这个6个部分，6个可变成的部分，把它拼装成一个包，把它定义成一个pipeline


###PHV(Packet Header Vector)
![18](图片/18.png)
你可以想象成，如果我们 pipeline 是一个人的话。每个 stage 可以说是一些器官，那中间他们传的这些数据哎，类似于血液一样的东西，那就是靠 PHV这个结构来去传递,如果没有PHV的话，信息传不过去。
PHV是什么时候产生的？是在Parser这边产生的。或者是从报文里面拷贝到 PHV里面，或者是从一些其他地方，比如说复制一份，或者直接赋值到 PHV里，PHV跟着这个包一起走到 MAU(Match——action units) 里的每一步。这个包在 stage 0的时候，它带着这个 PHV 信息，这4K 的比特就陪着它一起在 stage 里以及做各种查表。一直到 Deparser 这边会把 PHV 里的信息再写回报文里。
注意这个所有的 MAU 的处理其实都是针对 PHV 的。所以我们在 MAU 处理的时候，它并没有直接去改报文，它是改的是PHV

#### T-PHV
源数据从头带到尾，在这个12个 stage 里去用T-PHV是完全不进去 stage，它是只是只是占个位置。然后送到Deparser 去。那他是做什么用的？他是假如说我中间有些数据，我要把它不得不把它解析出来，因为我后边我还有重要的数据要去查表，但是我这个数据本身我只是把它解析出来。我也后边我也不会用到它，我可能就是出稿的时候重新组织这个报头的时候，我把原始原来那个数据再给它写过去。

#### POV(Packet Occupancy Vector)
P4编写的时候，其实可以看到P4，它是支持说我去添加一些 header，我去删除一些 header，这个删除操作是怎么做的？实际上，它是每个报文头，我们都有一个。这个和 valid bit 就是代表这个报文是不是存在。注意这个P4 里面介绍这个 value 的并不是说这个报文格式是不是合法，每一个比特代表一个对应的头是不是存在，那当然它是也是存在 PHV 的一个 container 里边的。那我们编写 P4 的时候把一个头加上，就是 set value 这个操作，把油头去掉就是 setinvalid 这个操作。这样在 deparser 的时候，我看到它是1，我就是添加这个从或者是原来有的话，就是保留这个头，如果它是0的话，我就把它去掉。

那还有些特殊的处理，绝大部分的这个以 trace manager，我是设置它以后它就生效，不设置它的话它就无效，或者有个默认值。但是有几个特殊的，像这个组播组，它是有单独的 validate。它是有单独一个是否存在的这么一个表示。但如果你前面逻辑你设了一个组播组等于1，后边你又反悔了，查另外一个表，说这个包不能做组播操作。那这个时候我们就要做一些特殊的操作了，那你需要做的就是一个特殊的语句，叫 invalidate.
![19](图片/19.jpg)
并且包括你从报文里提取出来的所有的header，包括你定义的所有的源数据，Metadata，还有一些就是我们芯片在建的源数据 intrinsic Medata 里所有的这些东西都会占用 PHV 资源。

###My P4
![20](图片/20.png)
可以我们去加一个表项，key多少等于那个actions是多少在PipeMgr，那么这样的话就是说我们表项的信息，它是进入一个 P4编程，表项它是不一样的。但是我们 API 就是固定，这样的话其实就对我们的那个变成有很大的好处。

SDE是啥？